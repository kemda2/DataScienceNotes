# Python ve Diğer Programlama Dilleri

Python, veri profesyonelleri arasında en popüler programlama dillerinden biridir ve bu da onu veri analitiği araç kutunuza eklemek için harika bir seçenek yapar! Daha önce incelediğimiz gibi, Python’un komutları iletmek ve görevleri gerçekleştirmek için kullandığı sözdizimi (syntax), konuşulan dile benzer. Bu da Python’u öğrenmesi çok daha kolay bir programlama dili yapar. Python’un yapısı birçok başka programlama diline benzese de, dikkate alınması gereken bazı önemli farklılıklar vardır.

Bu okuma materyalinde, Python’un veri profesyonellerinin kullandığı diğer programlama dilleri olan R, Java ve C++ ile nasıl karşılaştırıldığını öğreneceksiniz.

## Programlama Dillerinde Beş Önemli Nokta

Python, veri analizi için kullanılan tek programlama dili değildir, ancak en yaygın ve en güçlü olanlardan biridir. Birçok veri profesyoneli birden fazla programlama dili kullanır. Her dilin avantajları ve dezavantajları vardır. Bu kurs kapsamında, şu beş noktayı inceleyeceğiz: hız, erişilebilirlik, değişkenler, veri bilimi odaklılık ve programlama paradigması.

### **Hız**

Bir programın çalıştırılma hızına etki eden birçok faktör vardır; derleme süresi, çalışma zamanı, donanım, yüklü bağımlılıklar ve kodun verimliliği bunlardan bazılarıdır. Genel olarak, düşük seviyeli programlama dilleri daha hızlıdır ancak öğrenmesi ve kullanması daha zordur.

### **Erişilebilirlik**

Erişilebilirlik, yeni başlayanların bir dili ne kadar kolay kullanmaya başlayabildiğini ifade eder. Yeni programlama dillerini öğrenmek, sözdizimi ve genel yapıya bağlı olarak zor olabilir. **Sözdizimi (syntax)**, kod kelimeleri, semboller, yerleşim ve noktalama işaretlerinin yapısıdır. Semantik ise bu yapılar içinde değişkenler ve nesneler kullanarak anlam oluşturur. Ayrıca, bu değişkenler programlara esneklik katarken, nesneler verilerin tutulduğu yerlerdir.

### **Değişkenler**

Kod içindeki bilgiler değişkenlerde saklanır. **Değişken**, bilgisayarın hafızasında ayrılmış bir alanda değerleri saklayan isimlendirilmiş bir kutudur. Programlama dillerinin değişkenleri kullanma biçimi, bir sistemin temel işlemlerini veya çekirdek hızını etkiler. Bazı diller, programın tamamı boyunca değer koruyan statik değişkenler kullanır. Diğerleri ise değişkenleri dinamik olarak ele alır, böylece değerler program çalışırken belirlenebilir. Bazı diller ise deklaratif değişkenlere izin verir, bu da programın değişkenin nerede tutulacağını belirlemesine olanak tanır.

### **Veri Bilimi Odaklılık**

Programlama dillerinin kendine özgü özellikleri vardır ve veri analizindeki farklı görevlerde daha iyi hizmet verebilirler; bu yüzden programcılar onları belirli veri bilimi görevleri için tercih eder.

### **Programlama Paradigması**

Programlama dilleri nesne yönelimli, fonksiyonel veya emirsel olabilir. Nesne yönelimli programlama dilleri veri nesneleri etrafında modellenir. Fonksiyonel programlama dilleri fonksiyonlar etrafında modellenirken, emirsel diller programın durumunu değiştirebilen kod ifadeleri etrafında modellenir.

## Programlama Dili Karşılaştırmaları

Python, R, Java ve C++, veri analizi için en yaygın kullanılan dört programlama dilidir. Aşağıdaki tablo, bu dilleri hız, erişilebilirlik, değişken kullanımı, veri bilimi odaklılık ve programlama paradigması açısından karşılaştırmaktadır.

| Özellikler                  | Python                             | R                                                       | Java                                           | C++                                          |
| --------------------------- | ---------------------------------- | ------------------------------------------------------- | ---------------------------------------------- | -------------------------------------------- |
| **Hız**                     | Daha yavaş                         | Yapılandırma ve eklentilere bağlı                       | Daha hızlı                                     | Çok hızlı                                    |
| **Erişilebilirlik**         | Öğrenmesi kolay                    | Karmaşık                                                | Öğrenmesi kolay                                | Karmaşık                                     |
| **Değişken**                | Dinamik                            | Dinamik                                                 | Statik                                         | Deklaratif                                   |
| **Veri Bilimi Odaklılık**   | Makine öğrenimi ve otomatik analiz | Keşifsel veri analizi ve geniş istatistik kütüphaneleri | Açık kaynak varlıklarla proje bazlı kullanılır | Yaygın kullanılmasa da çok güçlü uygulamalar |
| **Programlama Paradigması** | Nesne yönelimli                    | Fonksiyonel dil                                         | Nesne yönelimli                                | Çok paradigmalı (emirsel & nesne yönelimli)  |

## Önemli Noktalar

Veri analizi için kullanılabilecek birçok farklı programlama dili vardır. Her dilin kendi avantajları ve dezavantajları bulunur. Farklı dilleri öğrenmek, veri becerilerinizi genişletme ve analizleriniz için yeni araçlara erişim fırsatı sunar. Ancak bu sertifika programında odak noktanız yalnızca Python olacaktır. Daha önce belirtildiği gibi, Python öğrenmesi kolay, nesne yönelimli ve dinamik değişken kullanan bir programlama dilidir; bazen çalışması daha uzun sürebilir ama makine öğrenimi ve otomatik analiz için mükemmel bir araçtır.

# Jupyter Notebooks Nasıl Kullanılır

Jupyter Notebook, canlı kod, matematiksel formüller, görselleştirmeler ve metin içeren belgeler oluşturup paylaşmak için açık kaynaklı bir web uygulamasıdır. Standartlaştırılmış, etkileşimli ve paylaşılabilir bir metin blok formatında kod geliştirmek ve sunmak için harika bir araçtır. Jupyter notebook’larda kod yazabilir, matematiksel formüller oluşturabilir, veri görselleştirmeleri yapabilir ve serbest biçimli metinler ekleyebilirsiniz!

Bu program boyunca kendi kodunuzu yazmak, çalıştırmak ve sunmak için Jupyter notebook’ları kullanacaksınız. Bu okuma materyali, kendi notebook’unuzu nasıl kullanacağınızı adım adım anlatacak. Ancak, bu sertifika programı için herhangi bir yazılım indirmenize gerek yoktur. Tüm aktiviteleri Coursera platformunda sunulan araçlarla tamamlayabilirsiniz.

## Jupyter Notebook

Jupyter Notebook’a doğrudan tarayıcınızdan erişebilir veya masaüstü uygulamasını indirip cihazınıza kurabilirsiniz. Bu uygulama, R ve Python gibi 100’den fazla programlama dili ile çalışmanıza olanak tanır. Ayrıca, hesaplama notebook’larıyla çalışmak için tam bir araç seti sunan [JupyterLab](https://jupyterlab.readthedocs.io/en/latest/) ve daha sade ama güçlü bir araç olan [Jupyter Notebook](https://jupyter-notebook.readthedocs.io/en/stable/) seçenekleri mevcuttur. Bu sertifika programı için Coursera tarafından sağlanan Jupyter Notebook arayüzünü kullanmanız önerilir. Jupyter notebook’ları gerektiren aktiviteler “lab” olarak etiketlenir ve her aktivite sayfasında ilgili yönergeler bulunur.

## Neden Jupyter Notebook?

Notebook’lar veri ile çalışmak için özellikle faydalıdır. İşte Jupyter notebook’ların öne çıktığı bazı noktalar:

1. **Modüler/etkileşimli programlama:** Kod parçalarını “hücre” (cell) adı verilen küçük, yönetilebilir bölümlerde yazabilir ve çalıştırabilirsiniz. Bir hücreyi çalıştırmak için tüm notebook’u çalıştırmanız gerekmez. Bu özellik, veri keşfi ve deney yaparken çok faydalıdır. Hücreler aynı zamanda hata ayıklama için uygundur; hatanızı fark edip düzeltmek için tüm betiği yeniden çalıştırmak zorunda kalmazsınız.

2. **Kod ve dokümantasyonun entegrasyonu:** Kod, metinsel açıklamalar ve grafik, tablo gibi görselleştirmeleri tek bir belgede birleştirmenizi sağlar.

3. **Çoklu dil desteği:** İleri Veri Analitiği programında Python kullanacağız, ancak Jupyter birçok farklı dili destekleyerek güçlü ve çok yönlü bir ortam sunar.

4. **Veri keşfi ve analizi:** Veriyi yüklemek, temizlemek, analiz etmek ve incelemek için sade ve şık araçlar sağlar.

5. **Bulut tabanlı hizmetler:** Birçok bulut platformu Jupyter notebook’ları barındırır, böylece yerel ortam kurmadan kolayca çalıştırıp paylaşabilirsiniz. Bu işbirliği için çok kullanışlıdır.

6. **Kütüphaneler ve eklentiler:** Projelerinizin ihtiyaçlarına göre işlevselliği artıran zengin bir eklenti ve uzantı ekosistemi vardır.

## Jupyter notebook’ları nasıl kullanılır?

Bir Jupyter notebook açtıktan sonra kullanmaya başlayabilirsiniz! İşte başlangıç için bazı ipuçları.

### Komut/Düzenleme Modu

Notebook’ların iki çalışma modu vardır: komut modu ve düzenleme modu. Komut modu, notebook’u bütün olarak kontrol etmek, hücre eklemek, taşımak ve silmek için kullanılır. Düzenleme modu ise bir hücreye kod veya markdown metni yazmak içindir.

Komut modu, aktif hücrenin solunda mavi bir çubuk ile gösterilir.

![image](images/2001.png)

Düzenleme modu, aktif hücrenin solunda yeşil çubuk ve ince yeşil bir kenarlık ile belirtilir.

![image](images/2002.png)

Düzenleme moduna girmek için bir hücreye tıklayın ya da klavyenizle hücre seçip Enter tuşuna basın. Komut moduna dönmek için hücre dışına tıklayın veya Escape tuşuna basın.

### Markdown Modu

Jupyter notebook’larda hücreleri kod modundan Markdown moduna geçirebilirsiniz. Markdown, düz metne biçimlendirme eklemenizi sağlayan bir işaretleme dilidir. Yaygın, geleceğe dönük ve platformdan bağımsız olması sebebiyle çok kullanışlıdır. Jupyter’de Markdown, kodun ve çıktısının açıklanması için yazılı metin oluşturmanızı sağlar. Örneğin, “In \[41]:” üstündeki tüm metin Markdown kullanılarak yazılmıştır ve biçimlendirilmiştir.

![image](images/2003.png)

Kod ile Markdown arasında geçiş yapmak için sayfanın üstündeki menüde “Code” yazan yere tıklayın, açılan menüden “Markdown” seçeneğini işaretleyin.

![image](images/2004.png)

Markdown kullanımı hakkında daha fazla bilgi için [Markdown temel sözdizimi rehberi](https://www.markdownguide.org/basic-syntax/) ve [Markdown genişletilmiş sözdizimi rehberi](https://www.markdownguide.org/extended-syntax/) sayfalarına bakabilirsiniz.

### Yaygın işlemler

Çoğu işlem hem fare/grafik arayüzü hem de klavye kısayollarıyla yapılabilir. İşte en yaygın işlemler:

### Yeni hücre ekleme

* Notebook üst menüsünde “Insert”e tıklayın. Mevcut hücrenin üstüne ya da altına yeni hücre ekleyebilirsiniz.

* Klavye kısayolları (komut modundayken):

  * **a:** Mevcut hücrenin üstüne hücre ekler
  * **b:** Mevcut hücrenin altına hücre ekler

### Hücre silme

* Komut modunda hücre veya hücreleri seçin.

* Üst menüden “Edit” → “Delete Cells” seçeneğine tıklayın.

* Klavye kısayolu (komut modundayken):

  * **dd** (D tuşuna iki kez basın)

### Hücre taşıma

* Komut modunda hücre veya hücreleri seçin.

* Üst menüdeki yukarı veya aşağı ok butonlarına tıklayarak seçili hücreleri yukarı veya aşağı taşıyın.

### Hücreyi çalıştırma

* Bir hücre seçip üst menüdeki **Run** butonuna tıklayın.

* Klavye kısayolları:

  * **Ctrl + Enter:** Seçili hücreyi çalıştırır
  * **Shift + Enter:** Seçili hücreyi çalıştırır ve bir sonraki hücreyi seçer
  * **Alt + Enter:** Seçili hücreyi çalıştırır ve altına yeni hücre ekler

* Hücreleri hem komut modunda hem de düzenleme modunda çalıştırabilirsiniz.

Komut modundayken **h** tuşuna basarsanız, tüm klavye kısayollarının listelendiği bir pencere açılır. Daha detaylı özellikler için [Jupyter Notebook arayüz bileşenleri](https://jupyter-notebook.readthedocs.io/en/stable/ui_components.html) sayfasına bakabilirsiniz.

## Sorun Giderme

İleri Veri Analitiği sertifika programı boyunca Jupyter notebook’ları kullanacaksınız. Bazen notebook’a erişirken veya çalıştırırken sorun yaşayabilirsiniz. İşte bazı çözüm önerileri.

### Tarayıcı uyumluluğu

Tarayıcınızın güncel olduğundan emin olun. Google Chrome, Firefox veya Microsoft Edge’in en son sürümlerini kullanmanız en iyisidir. Eğer eski bir tarayıcı kullanıyorsanız veya Coursera tarafından desteklenmeyen bir tarayıcı kullanıyorsanız sorun yaşayabilirsiniz. Tarayıcınız güncelyse ve yine de sorun yaşıyorsanız, tarayıcınızı yeniden başlatın veya önbellek ile çerezleri temizleyin. Gizli mod (incognito) kullanmak da çerezlerin kaydedilmesini önler.

### İnternet bağlantısı

Coursera stabil internet bağlantısı gerektirir. Jupyter notebook açarken veya çalıştırırken sorun yaşıyorsanız internet bağlantınız yavaş ya da kararsız olabilir. Sayfaların yüklenmemesi, laboratuvarların donması ya da komut yazamamak kararsız bağlantı belirtileridir.

**İpucu:** Bir cihazda laboratuvarı tamamlayamıyorsanız başka bir cihaz deneyin.

### Sorun giderme adımları

Özetle, Jupyter notebook ile ilgili sorun yaşarsanız şu adımları deneyin:

1. Desteklenen tarayıcıların en güncel sürümlerini (Chrome, Firefox, Edge) kullandığınızdan emin olun.
2. Tarayıcınızı yeniden başlatın ve önbellek ile çerezleri temizleyin. Gizli modu deneyin.
3. İnternet bağlantınızı kontrol edin ve gerekirse modem/router’ınızı yeniden başlatın.
4. Laboratuvarı yeniden başlatmayı deneyin.

Eğer bunlar işe yaramazsa, Coursera bakım yapıyor ya da hizmet kesintisi yaşıyor olabilir. Bir süre bekleyip tekrar deneyin.

## Özet

Jupyter Notebook, kendi kodunuzu geliştirebileceğiniz ve hata ayıklayabileceğiniz bir platform sağlar. Notebook’ları kullanmayı bilmek, yeni Python becerilerini deneyeceğiniz ve kurs sonu projesine hazırlanacağınız aktiviteler için sizi hazırlar. Python, makine öğrenimi ve otomatik analiz gibi ileri analiz araçlarını açacak mükemmel bir araçtır. Jupyter Notebook kullanmak ise Python bilginizi artırmak için harika bir yoldur!

## Daha fazla bilgi için kaynaklar

* [Jupyter Notebook arayüz eğitimi](https://jupyter-notebook.readthedocs.io/en/stable/ui_components.html)
* [Jupyter yazılım ana sayfası](https://jupyter.org/)
* [Jupyter dokümantasyonu](https://docs.jupyter.org/en/latest/)
* [Jupyter Notebooks bulut ortamı (çevrimiçi)](https://jupyter.org/try-jupyter/notebooks/?path=notebooks/Intro.ipynb)
* [Jupyter topluluk forumu](https://discourse.jupyter.org/)
* [Jupyter notebook topluluk forumu](https://discourse.jupyter.org/c/notebook/3)
* [Python topluluk forumu](https://www.python.org/community/forums/)
* [StackOverflow (soru-cevap platformu)](https://stackoverflow.com/)
* [Jupyter Notebooks kurulumu](https://test-jupyter.readthedocs.io/en/latest/install.html)

# Nesne Yönelimli Programlama Hakkında Daha Fazlası

**Not:** Bu okuma, nesne yönelimli programlamaya yalnızca kısa bir giriş sunar. Nesne yönelimli programlamanın tüm ayrıntılarını ele almak, bu kursun kapsamı dışındadır.

Daha önce, nesne yönelimli programlamayı, hem verileri hem de bu verileri işleyen kodu içerebilen **nesneler** etrafında yapılandırılmış bir programlama paradigması olarak tanımlamıştık. Hatırlarsanız, sınıf (class), verileri ve işlevselliği bir arada tutan bir veri türüdür ve bu sınıfa ait işlevselliğin örneklerini **yöntemler (methods)** ve **özellikler (attributes)** şeklinde görmüştünüz. Bu okumada, nesne yönelimli programlamayı biraz daha ayrıntılı inceleyeceksiniz. Bu sertifika programı boyunca kendi sınıflarınızı tanımlamanız gerekmeyecek, ancak bu sürecin nasıl çalıştığını temel düzeyde anlamanız, öğrenme süreciniz boyunca karşılaşacağınız bu kavramlar açısından size oldukça yardımcı olacaktır.

---

## Gözden Geçirme: Özellikler ve Yöntemler

Python sınıfları, yerleşik (built-in) özellikler sayesinde güçlü ve kullanışlıdır. Bu özellikler, veri analizinde sık karşılaşılan görevleri kolaylaştırır ve iki ana kategoriye ayrılır:

* **Özellik (Attribute):** Bir nesneye veya sınıfa ait, nokta gösterimi (dot notation) kullanılarak erişilen değerdir.
* **Yöntem (Method):** Bir sınıfa ait olan ve genellikle bir işlem gerçekleştiren fonksiyondur.

Bunları ayırt etmenin daha basit bir yolu şudur:
**Özellikler**, nesnenin *karakteristikleri* (örneğin adı, türü, hızı),
**Yöntemler** ise nesnenin *eylemleri* veya \_işlemleri\_dir (örneğin hareket etme, ışınlama).

Örneğin, sınıfımız “Spaceship” (Uzay Gemisi) olsun. Bu sınıfın özellikleri şunlar olabilir:

* name (isim)
* kind (tür)
* speed (hız)
* tractor\_beam (çekici ışın)

Bu özelliklere şu şekilde erişebilirsiniz:

```python
Spaceship.name  
Spaceship.kind  
Spaceship.speed  
Spaceship.tractor_beam
```

Gördüğünüz gibi sadece bir **nokta** kullanılarak erişilir.

Öte yandan, Spaceship sınıfının bazı yöntemleri şunlar olabilir:

* warp()
* tractor()

Bu yöntemleri şu şekilde kullanabilirsiniz:

```python
Spaceship.warp()  
Spaceship.tractor()
```

Dikkat ederseniz, yöntemler **parantez** ile çağrılır ve genellikle **argüman** alabilirler. Örneğin:

```python
Spaceship.warp(7)
```

Bu, geminin hızını "warp 7"ye ayarlayabilir.

---

## Benzersiz Özellik ve Yöntemlerle Sınıf Tanımlamak

Python’da kendi sınıflarınızı tanımlayabilir, bunlara özgü özellikler ve yöntemler ekleyebilirsiniz. Bu, geliştiricilerin yeniden kullanılabilir kodlar yazmasına ve işlerini daha verimli hale getirmelerine olanak tanır. Yukarıda bahsettiğimiz “Spaceship” sınıfını kendiniz de oluşturabilirsiniz. Aşağıdaki örnek bunu göstermektedir.

**Not:** Aşağıdaki kod bloğu etkileşimli değildir.

```python
class Spaceship:
    # Sınıf özelliği
    tractor_beam = 'off'

    # Örnek özellikleri
    def __init__(self, name, kind):
        self.name = name
        self.kind = kind
        self.speed = None

    # Örnek yöntemler
    def warp(self, warp):
        self.speed = warp
        print(f'Warp {warp}, engage!')

    def tractor(self):
        if self.tractor_beam == 'off':
            self.tractor_beam = 'on'
            print('Tractor beam on.')
        else:
            self.tractor_beam = 'off'
            print('Tractor beam off')
```

Bu kurs için kendi sınıflarınızı oluşturacak sözdizimini ezberlemeniz gerekmez. Sadece şunu fark etmeniz yeterlidir: sınıf tanımlandıktan sonra, ona ait özellikler ve yöntemler **girintili olarak** (indent) yazılır. Bir özelliğin veya yöntemin bir sınıfa “ait” olması işte bunu ifade eder.

Bir sınıf, belirli ortak **özellikleri** ve **davranışları** olan her şey için bir **şablon** gibidir. Burada sınıfımız `Spaceship`. Farklı türde birçok uzay gemisi olabilir. Hepsinin adı, türü, amacı farklı olabilir.

Bir sınıfa ait nesne oluşturduğunuzda, o sınıfın bir **örneğini (instance)** oluşturmuş olursunuz. Buna **class instantiation** (sınıf örnekleme) denir.

Aşağıdaki kod, `Spaceship` sınıfının bir örneğini oluşturur ve bazı özelliklerini kontrol eder:

```python
# Spaceship sınıfının bir örneğini oluştur
ship = Spaceship('Mockingbird', 'rescue frigate')

# Geminin adını yazdır
print(ship.name)

# Gemi türünü yazdır
print(ship.kind)

# Çekici ışın durumu
print(ship.tractor_beam)

# Çıktı:
# Mockingbird
# rescue frigate
# off
```

Sonraki kod bloğu `warp()` yöntemini kullanarak warp hızını 7 olarak ayarlar ve geminin hızını kontrol eder:

```python
# Warp hızını ayarla
ship.warp(7)

# Hızı kontrol et
ship.speed

# Çıktı:
# Warp 7, engage!
# 7
```

Son örnek `tractor()` yöntemini kullanarak çekici ışını açıp kapatır ve son durumu kontrol eder:

```python
# Çekici ışını aç/kapat
ship.tractor()

# Durumu kontrol et
print(ship.tractor_beam)

# Çıktı:
# Tractor beam on.
# on
```

Bu sadece sınıfların, özelliklerin ve yöntemlerin temel çalışma şeklini göstermek için verilmiş basit bir örnektir. Gerçek dünyada sınıflar çok daha karmaşık olabilir ve çok sayıda özellik ve yöntem içerebilir.

Bir veri analisti olarak çalışırken, sınıf tanımlama, özellik ve yöntemler oluşturma bilgisi; verideki desenleri, ilişkileri ve anlamları araştırmak için oldukça yararlı olacaktır.

---

## Temel Bilgiler – Özet

Sınıflar, Python’un temel nesnelerinden biridir ve bu nedenle Python bir **nesne yönelimli programlama dili** olarak bilinir. Sınıf nesneleri güçlüdür çünkü kendi sınıflarına özgü araçları (özellik ve yöntemleri) içlerinde barındırırlar.

* **Yöntemler**, bir sınıfa ait olan ve bir işlem gerçekleştiren fonksiyonlardır. Parantez kullanılır.
* **Özellikler**, bir sınıf ya da sınıf örneğine ait olan değer veya karakteristiklerdir. Parantez **kullanılmaz**.

Python’da pek çok yerleşik sınıf, özellik ve yöntem vardır; ancak nesne yönelimli programlama, yüksek düzeyde **özelleştirme** olanağı da sağlar.

Elbette! İşte “Explore Python syntax” başlıklı metnin Türkçe çevirisi:

---

# Python Söz Dizimini Keşfedin

Python, yazılım geliştirme, makine öğrenimi ve veri analizi gibi birçok alanda kullanılan esnek bir programlama dilidir. Python, veri profesyonelleri arasında en popüler dillerden biridir. Bu nedenle, temel söz dizimi (syntax) ve anlambilimi (semantics) ile tanışmanız gelecekteki kariyeriniz açısından oldukça faydalı olacaktır. Bu okumada, Python’un söz dizimini ve anlambilimini öğrenecek, ayrıca öğreniminizi ilerletmek için kullanabileceğiniz kaynakları keşfedeceksiniz.

---

## Python’un Dili

İnsanlar birbirleriyle iletişim kurmak ve talimat vermek için dil kullanır. Bilgisayarlar da aynı şekilde iletişim kurar, ancak Python, C++ ve Java gibi dilleri kullanarak. Bu nedenle, bir bilgisayara komut verebilmek için, programcılar fikir ve kavramları bilgisayarın anlayabileceği bir dile dönüştürmelidir.

Python’un söz dizimi, nesneleri ve komutları temsil eden kelimeler ile bu kelimelere yapı, hiyerarşi ve bağlam kazandıran noktalama işaretlerini içerir. Bu kelimeler ve noktalama işaretleri birlikte fikirleri ve işlemleri ifade eder; buna **anlambilim (semantics)** denir. Yani anlambilim, söz dizimiyle aktarılan anlamdır. Söz dizimini ve anlambilimi öğrenmenin en iyi yolu, sık sık maruz kalmaktır: bol bol kod yazmak ve başkalarının kodlarını okumak. Ayrıca, programcıların dil içinde tutarlılığı korumak için takip ettiği genel kabul görmüş bazı kurallar da vardır.

Kodlama dilleri, konuşma dillerine benzer şekilde, kelimeleri işlevlerine göre sınıflandırır. Örneğin, İngilizce’de cümleler isimler, fiiller, edatlar gibi parçalardan oluşur.

İşte bazı temel kavramlar:

---

### Değişkenler (Variables)

Verileri temsil eder. Bu veriler string (metin), tuple (demet), dictionary (sözlük), list (liste) ve nesne (object) gibi türlerde olabilir. (İlerleyen okumalar bu türleri açıklayacak.)

* Örnek: `student_name`

---

### Anahtar Kelimeler (Keywords)

Belirli amaçlara ayrılmış özel kelimelerdir. Sadece bu amaçlar için kullanılabilirler.

* Örnekler:

  * `in`
  * `not`
  * `or`
  * `for`
  * `while`
  * `return`

---

### Operatörler (Operators)

Nesneler ve değerler üzerinde işlemler gerçekleştiren sembollerdir.

* Örnekler:

  * `+` Toplama
  * `-` Çıkarma
  * `*` Çarpma
  * `/` Bölme
  * `**` Üs alma
  * `%` Mod alma (kalanı döndürür). Örnek: `10 % 3 = 1`
  * `//` Tamsayı bölme (sonucu aşağı yuvarlar). Örnek: `5 // 2 = 2`
  * `>` Büyüktür
  * `<` Küçüktür
  * `==` Eşittir

---

### İfadeler (Expressions)

Sayıların, sembollerin ve değişkenlerin bir kombinasyonudur. Değerlendirildiğinde bir sonuç döndürür.

* Örnek: `[1, 2, 3] + [2, 4, 6]`

---

### Fonksiyonlar (Functions)

Belirli bir görevi yerine getirmek ve bir değer döndürmek için kullanılan, ilişkili komutlardan oluşan yapıdır.

* Örnek:

```python
def to_celsius(x):
    '''Fahrenheit'ı Celsius'a çevir'''
    return (x - 32) * 5/9

to_celsius(75)
# Çıktı: 23.88888888888889
```

---

### Koşullu İfadeler (Conditional Statements)

Programın akışını belirli koşullara göre yönlendiren kod bölümleridir.

* Örnek:

```python
number = -4

if number > 0:
    print('Sayı pozitiftir.')
elif number == 0:
    print('Sayı sıfırdır.')
else:
    print('Sayı negatiftir.')

# Çıktı: Sayı negatiftir.
```

---

Python, yanlış kullanılan anahtar kelimeler veya söz dizimi nedeniyle **sözdizimi hataları (syntax error)** üretir.

* Örnek:

```python
print(This will throw an error because I didn’t make it a string.)

# Satır 1'de hata:
#     print(This will throw an error because I didn’t make it a string.)
#                   ^
# SyntaxError: invalid syntax
```

---

## İsimlendirme Kuralları ve Standartları

Nesnelere (değişken, fonksiyon vb.) isim verirken, kodun standartlaşmasını ve daha kolay anlaşılmasını sağlamak için bazı kurallar ve konvansiyonlar vardır:

* İsimlerde **boşluk** olamaz.
* Büyük ve küçük harfler birlikte kullanılabilir.
* İsimler **sayı ile başlayamaz**, ancak ilk harften sonra sayı içerebilir.
* Değişken ve fonksiyon isimleri **snake\_case** formatında yazılmalıdır. Yani tüm harfler küçük olmalı ve kelimeler **alt çizgiyle** (`_`) ayrılmalıdır.
* Açıklayıcı isimler, kısaltmalardan daha iyidir. Örneğin, `student_name` değişkeni `sn`'den daha açıklayıcıdır.

---

### Python’un Zen’i

Python geliştiricisi **Tim Peters**’ın, Python yazım felsefesini özetleyen ünlü “şiiri”:

**The Zen of Python**

Güzel, çirkinden iyidir.
Açık, örtükten iyidir.
Basit, karmaşıktan iyidir.
Karmaşık, karma karışıktan iyidir.
Düz, iç içe geçmişten iyidir.
Seyrek, yoğun olandan iyidir.
**Okunabilirlik önemlidir.**
Özel durumlar kuralları bozacak kadar özel değildir.
Ancak işlerlik saflıktan önce gelir.
Hatalar sessizce geçiştirilmemelidir.
Ancak açıkça bastırılmadıkça.
Belirsizlik karşısında, tahmin etmekten kaçının.
Yapılacak şeyin **tek bir doğru yolu** olmalıdır (tercihen).
O yol ilk başta açık olmayabilir... eğer Hollandalı değilseniz.
Şimdi, asla'dan daha iyidir.
Ama bazen **şimdi hemen** yapmak, asla yapmamaktan daha kötüdür.
Bir şeyin uygulanışı zor anlatılıyorsa, o iyi bir fikir değildir.
Kolay anlatılıyorsa, iyi bir fikir olabilir.
Ad alanları harika bir fikir — daha fazlasını kullanalım!

---

Son olarak, Python’da stil konusundaki resmi kılavuz olan [**PEP 8** Stil Rehberi](https://peps.python.org/pep-0008/)’ni yer imlerinize eklemeniz önerilir. Bu okuma sınırlı bilgi sunar; PEP 8 ise stil konularını çok daha kapsamlı şekilde ele alır.

**PEP**, *Python Enhancement Proposals* (Python Geliştirme Önerileri) anlamına gelir. Python’un açık kaynaklı yapısı sayesinde bu öneriler, dilin geliştirilmesi ve standartlaşması için bir rehber görevi görür. Güvenilir ve faydalı bir kaynaktır.

---

## Ana Noktalar – Özet

Python’da **söz dizimi (syntax)** ve **anlambilim (semantics)**, dilin şekil ve anlam kazanmasını sağlar. Yeni bir programlama dili öğrenmenin büyük kısmı bu iki öğeye aşina olmaktan geçer. Bunun çoğu pratikle gelir, ancak bazı temel kurallar ve kaynaklar da sürecinizi kolaylaştırır.

Eğer nesne isimlendirme kurallarını öğrenir ve başvurabileceğiniz kaynakları bir araya getirirseniz, Python yolculuğunuzda kesinlikle ilerleme kaydedersiniz. Python’a alıştıkça, bilgisayarlarla daha verimli iletişim kurabilecek ve veri analiz araçlarınızla çok daha fazlasını yapabileceksiniz.

---

## Daha Fazla Bilgi İçin Kaynaklar

Python ile daha fazla pratik yapmak için bazı faydalı kaynaklar:

* Python [Referans Kütüphanesi](https://docs.python.org/3/library/)

  * [Yerleşik Veri Tipleri](https://docs.python.org/3/library/stdtypes.html)
  * [Yerleşik Fonksiyonlar](https://docs.python.org/3/library/functions.html#built-in-functions)
* \[Python Operatörleri]\([https://python-reference.readthedocs.io/en/latest/docs](https://python-reference.readthedocs.io/en/latest/docs/operators/index.html)

# Başvuru Kılavuzu: Fonksiyonlar

Öğrendiğiniz üzere, fonksiyonlar belirli işlemleri veya görevleri gerçekleştirmek için yeniden kullanılabilir kod bloklarıdır. Daha az kodla daha fazla iş yapmanızı sağlarlar. Fonksiyon örneklerine şunlar dahildir:

* Fahrenheit’ı Celsius’a çeviren bir hesaplama
* Miktarları dolaşıp stoktaki ürünlerin toplam maliyetini hesaplayan bir envanter aracı
* Bir seri ya da sözlük verisinden DataFrame oluşturma
* Yazım denetleyici gibi bir uygulama yardımcı aracı

Bu okumada, fonksiyonların nasıl tanımlandığını, oluşturulduğunu ve çağrıldığını öğreneceksiniz.

---

## Fonksiyon Söz Dizimi

Fonksiyonlar aşağıdaki söz dizimi ve formatla tanımlanır:

**Not:** Aşağıdaki kod bloğu etkileşimli değildir.

```python
def my_function(parameters):
    '''
    Açıklama satırı (docstring).
    Fonksiyonun ne yaptığını, parametrelerini ve döndürdüğü değeri açıklar.
    '''
    kod bloğu

    return değer
```

1. `def` anahtar kelimesiyle başlayın, ardından fonksiyonun adını yazın. Parantez içinde parametre(ler) belirtin ve `:` ile bitirin.

   * Python’da geleneksel olarak fonksiyon isimleri **snake\_case** (küçük harflerle yazılır, kelimeler alt çizgiyle ayrılır) kullanılarak yazılır.

2. Önemli fonksiyonlar için veya amacı net olmayan fonksiyonlar için bir **docstring** (açıklama satırı) ekleyin. Bu metin üç tırnak içinde yazılır.

   * Docstring bir **eylem ifadesi** olmalıdır. Örn: “İki sayıyı topla” (“İki sayıyı toplar” değil).
   * Fonksiyonun ne yaptığı, hangi parametreleri aldığı ve ne döndürdüğü açıklanmalıdır.
   * Docstring, tanım satırından dört boşluk içeride yazılmalıdır.

3. Fonksiyonun gövdesini yazın.

   * Tüm kod satırları en az dört boşluk içeride olmalıdır. Kod karmaşıklığına göre daha fazla girinti olabilir.

4. Son olarak, bir `return` ifadesi kullanarak bir değer döndürebilir veya `print` komutuyla konsola çıktı verebilirsiniz. Bu satır da dört boşluk içeride olmalıdır.

---

## **return vs. print**

Python öğrenmeye yeni başlayanlar için `return` ve `print` ifadeleri arasındaki fark karışık olabilir. Her birinin ne yaptığını ve ne zaman kullanılması gerektiğini anlamak önemlidir:

* `return`: Bir sonucu **geri döndürür**, bu sonuç daha sonra başka bir yerde kullanılabilir. Fonksiyon çalıştırıldığında ekrana yazdırılmak zorunda değildir.
* `print`: Yalnızca sonucu **konsola yazar**, ancak döndürülecek veya saklanacak bir veri üretmez.

**Benzetme:**
`return` ifadesi, kardeşinizin pazara gidip size bir torba patates getirmesi gibidir.
`print` ifadesi ise, kardeşinizin pazara gidip gelip orada ne tür patatesler olduğunu size anlatması gibidir.
`return` sayesinde elinizde pişirecek patates olur, `print` sayesinde ise sadece patates türlerini öğrenirsiniz ama elinizde patates olmaz.

---

## **Fonksiyonlar vs. Metotlar**

Fonksiyonlar ve metotlar birbirine benzese de bazı temel farklar vardır. **Metotlar**, özel bir fonksiyon türüdür. **Bir sınıfa ait** olan fonksiyonlardır. Bu nedenle, nokta (.) gösterimiyle çağrılırlar.

**Metot örneği:**

```python
my_string = 'The eagles filled the sky.'
my_string.split()

# ['The', 'eagles', 'filled', 'the', 'sky.']
```

`split` metodu, `string` sınıfına ait bir fonksiyondur. Bir string’i boşluklardan böler.

Bağımsız (standalone) fonksiyonlar ise belirli bir sınıfa ait değildir ve çoğu zaman farklı veri türleriyle birlikte kullanılabilir.

**Fonksiyon örneği:**

```python
sum([6, 3])
# 9
```

Python’un yerleşik fonksiyonlarını [Python’un yerleşik fonksiyon listesi](https://docs.python.org/3/library/functions.html) üzerinden inceleyebilir, [Jupyter forumu](https://discourse.jupyter.org/), [StackOverflow](https://stackoverflow.com/) ve diğer çevrimiçi topluluklardan bu fonksiyonların nasıl kullanıldığını görebilirsiniz.

---

## Daha Fazla Bilgi İçin Kaynaklar

Fonksiyonlar hakkında daha fazla bilgi edinmek isterseniz aşağıdaki kaynaklara göz atabilirsiniz:

* Python [Referans Kütüphanesi](https://docs.python.org/3/library/)
* [Veri Tipleri](https://docs.python.org/3/library/stdtypes.html)
* [Yerleşik Fonksiyonlar](https://docs.python.org/3/library/functions.html#built-in-functions)
* [Semboller](https://wiki.python.org/moin/PythonGlossary?action=AttachFile&do=view&target=PySymbols.html)

Öne çıkan yerleşik fonksiyonlar:

* [`enumerate()`](https://docs.python.org/3/library/functions.html#enumerate)
* [`isinstance()`](https://docs.python.org/3/library/functions.html#isinstance)
* [`dict()`](https://docs.python.org/3/library/functions.html#func-dict)
* [`type()`](https://docs.python.org/3/library/functions.html#type)
* [`len()`](https://docs.python.org/3/library/functions.html#len)
* [`set()`](https://docs.python.org/3/library/functions.html#func-set)
* [`zip()`](https://docs.python.org/3/library/functions.html#zip)

Ayrıca [PEP 257](https://peps.python.org/pep-0257/) dökümanı, docstring yazım standartlarını öğrenmeniz için yararlı bir kaynaktır.

# Başvuru Rehberi: Python Operatörleri

Python operatörleriyle şimdiye kadar birçok kez karşılaştınız. Bunların çoğu muhtemelen size oldukça tanıdık geliyordur. Sonuçta, Python’da toplama ve çıkarma gibi işlemler yeni kavramlar değildir. Ancak, temel aritmetik işlemlerin çok ötesinde birçok farklı operatör vardır!

**Operatörler**, belirli aritmetik ya da mantıksal işlemleri gerçekleştiren karakterlerdir. Veri profesyonelleri bu operatörleri çalışmalarında sıkça kullanır ve bunlar Python programlamanın temel bir parçasıdır. Bu okuma, Python’da kullanabileceğiniz çeşitli operatörleri tanıtan bir rehberdir.

## Karşılaştırma Operatörleri (Comparators)

Python’da karşılaştırma operatörlerini kullanarak değerleri karşılaştırabilirsiniz. Karşılaştırma yapıldığında Python bir **Boolean (doğru/yanlış)** sonucu döndürür. Aşağıdaki karşılaştırma operatörleri kullanılabilir:

| İşlem              | Operatör |
| ------------------ | -------- |
| Büyüktür           | `>`      |
| Büyük veya eşittir | `>=`     |
| Küçüktür           | `<`      |
| Küçük veya eşittir | `<=`     |
| Eşit değil         | `!=`     |
| Eşittir            | `==`     |

**Notlar:**

* Tek eşittir işareti (`=`) sadece **değer atama** işlemleri için kullanılır. Eğer bir karşılaştırma için tek eşittir kullanırsanız, Python **SyntaxError** hatası verir.
* Uyuşmayan veri türleri arasında karşılaştırma yaparsanız (örneğin bir string ile bir integer karşılaştırmak gibi), Python **TypeError** hatası verir.

---

## Mantıksal Operatörler (Logical Operators)

Python, karşılaştırma operatörleriyle birlikte kullanılabilen üç adet mantıksal operatör içerir:

* `and`: Her iki ifade de doğruysa sonuç **True** olur
* `or`: İfadelerden en az biri doğruysa sonuç **True** olur
* `not`: İfadenin değerini tersine çevirir

  * İfade True ise sonuç False olur; ifade False ise sonuç True olur

**Örnek:**

```python
x = 3
my_list = [3, 4, 6, 10]
print(x < 3 and x != 0)                        # False
print(x >= len(my_list) or x == min(my_list))  # True
print(x not in my_list)                        # False
```

---

## Aritmetik Operatörler

Python, yerleşik operatörler aracılığıyla matematiksel işlemleri de gerçekleştirebilir. Aşağıda Python’daki temel aritmetik operatörler yer almaktadır:

| İşlem                             | Operatör | Örnek          |
| --------------------------------- | -------- | -------------- |
| Toplama                           | `+`      | `[IN]  5 + 2`  |
|                                   |          | `[OUT] 7`      |
| Çıkarma                           | `-`      | `[IN]  5 - 2`  |
|                                   |          | `[OUT] 3`      |
| Çarpma                            | `*`      | `[IN]  5 * 2`  |
|                                   |          | `[OUT] 10`     |
| Bölme                             | `/`      | `[IN]  5 / 2`  |
|                                   |          | `[OUT] 2.5`    |
| Mod (bölme kalanı)                | `%`      | `[IN]  5 % 2`  |
|                                   |          | `[OUT] 1`      |
| Üs alma                           | `**`     | `[IN]  5 ** 2` |
|                                   |          | `[OUT] 25`     |
| Taban bölme (tam sayı bölme)      | `//`     | `[IN]  5 // 2` |
| (bölenin paydaya kaç kez sığdığı) |          | `[OUT] 2`      |

---

Python’da, ilerleyen aşamalarda özel kütüphaneler aracılığıyla çok daha karmaşık matematiksel işlemler de gerçekleştirilebilir. Ancak Python’un çekirdeğinde, bu temel operatörler sayesinde karşılaştırma, mantıksal işlemler ve matematiksel hesaplamalar yapılabilir. Bu operatörler, birçok ifadede birleştirilerek sonsuz sayıda işlem gerçekleştirmek mümkündür.

# Başvuru Rehberi: Koşullu İfadeler

Koşullu ifadeler, programlamanın temel bir parçasıdır. Belirli koşullara göre bilgi akışını kontrol etmenizi sağlarlar. Python'da koşullu ifadeleri uygulamak için `if`, `elif` ve `else` deyimleri kullanılır. Program yürütmesini dallandırmak (koşullara göre farklı yönlere ilerletmek), veri profesyonelleri için kodlamanın temel unsurlarındandır. Bu nedenle koşullu ifadelerin nasıl çalıştığını anlamak oldukça önemlidir. Bu doküman, koşullu ifadelere yönelik bir başvuru rehberidir.

---

## Koşullu Yapılar (Sözdizimi)

Önceki videolarda, Python’daki bazı yerleşik karşılaştırma ve mantıksal operatörleri öğrendiniz. Bu operatörleri, `if-elif-else` bloklarında nasıl kullanacağınızı da gördünüz.

> **Not:** Aşağıdaki kod bloğu etkileşimli değildir.

Python'da `if-elif-else` ifadelerinin temel sözdizimi şu şekildedir:

```python
if condition1:
   # Koşul True ise çalışacak kod bloğu

elif condition2:
   # condition1 False ve condition2 True ise çalışacak kod bloğu

else:
   # Her iki koşul da False ise çalışacak kod bloğu
```

Burada `condition1` ve `condition2`, `True` ya da `False` değerine sahip olan ifadeler (koşullar) olmalıdır. `if` bloğundaki koşul doğruysa, ilgili kod bloğu çalışır; değilse atlanır.

`elif` ("else if" anlamına gelir) bir önceki `if` koşulu yanlışsa başka bir koşul kontrol etmek için kullanılır. Kodunuzda istediğiniz kadar `elif` kullanabilirsiniz.

`else` ise `if` ve tüm `elif` koşulları yanlış olduğunda çalışacak kodu belirtmek için kullanılır.

### Örnek:

```python
x = 8
if x > 5:
   print('x beşten büyüktür')
elif x < 5:
   print('x beşten küçüktür')
else:
   print('x beşe eşittir')

# Çıktı: x beşten büyüktür
```

---

### `else` Kullanımını Atlamak

Çoğu zaman, `else` bloğu mantıksal olarak gerekli olmadığı için kullanılmaz. Aşağıdaki örneği inceleyin:

```python
def greater_than_ten(x):
    if x > 10:
        return True
    else:
        return False

print(greater_than_ten(15))
print(greater_than_ten(2))

# Çıktı:
# True
# False
```

Bu fonksiyon, `x` 10’dan büyükse `True`, değilse `False` döndürür. Kod tamamen doğrudur ve sıkça bu şekilde kullanılır. Dikkat ederseniz `else`, kendi satırında yer alır ve altındaki `return` ifadesi girintilidir.

Ancak aşağıdaki kod da aynı işlemi yapar ve genellikle tercih edilir:

```python
def greater_than_ten(x):
    if x > 10:
        return True
    return False

print(greater_than_ten(15))
print(greater_than_ten(2))

# Çıktı:
# True
# False
```

Bu durumda `else` bloğu yok, fakat mantıksal işleyiş aynıdır. Fonksiyon yukarıdan aşağıya doğru çalışır. Satır 2’de `x > 10` kontrol edilir. Eğer bu doğruysa, 3. satırdaki `return True` çalışır ve fonksiyon sona erer.

Ancak koşul sağlanmazsa, 3. satır atlanır ve doğrudan 4. satıra geçilir. Bu satırda `return False` ifadesi vardır ve çalıştırılarak fonksiyon sona erer. Ayrıca `return False` ifadesinin `if` bloğuyla aynı girinti seviyesinde olduğunu da unutmayın.

Programlama becerileriniz geliştikçe, bu iki yaklaşımdan hangisini tercih edeceğinizi kendiniz belirleyebilirsiniz. İkisine de aşina olmanızda fayda var.

---

## Temel Noktalar

Python’daki koşullu ifadelerle ilgili bilmeniz gereken bazı önemli noktalar:

* `elif` ve `else` kullanımı zorunlu değildir. Tek başına bir `if` ifadesi yeterlidir.
* Birden fazla `elif` ifadesi kullanabilirsiniz.
* Sadece bir tane `else` ifadesi olabilir ve bu en sona yazılmalıdır.
* Koşullar, Boolean (True veya False) döndüren ifadeler olmalıdır.
* **Girintileme çok önemlidir!** Her koşullu ifade ile ilişkili kodlar alt satıra dört boşluk girintisiyle yazılmalıdır. Yanlış girintileme, en sık görülen hatalı kod davranışlarının nedenidir.

# Döngüler, `break` ve `continue` İfadeleri

Python’da `while` döngülerini öğrendiniz ve bazı örnekler incelediniz. `while` döngüleri, belirli bir koşul sağlanana kadar bir işlemi ya da değerlendirmeyi tekrar tekrar gerçekleştirmenize olanak tanır ve ardından durur. Bu, yalnızca Python’da değil, çoğu programlama dilinde önemli bir süreçtir. Veri profesyonelleri verileri işlerken `while` döngülerini sıkça kullanır. Bu nedenle, becerilerinizi geliştirirken bu yapıya alışmanız önemlidir. Bu içerik, `while` döngülerinin temel kavramlarını gözden geçirmenizi sağlar.

---

## While Döngüsü Sözdizimi

`while` döngüsü, belirli bir koşul doğru olduğu sürece bir kod bloğunu tekrar tekrar çalıştırmanıza izin veren bir kontrol yapısıdır.

> **Not:** Aşağıdaki kod bloğu etkileşimli değildir.

Temel `while` döngüsü sözdizimi şu şekildedir:

```python
while koşul:
   # Çalıştırılacak kod bloğu
```

Koşul, her döngü yinelemesinin başında değerlendirilen bir Boolean (True veya False) ifadedir. Koşul doğruysa, kod bloğu çalışır. Ardından koşul tekrar kontrol edilir. Bu süreç, koşul yanlış olana kadar devam eder. Koşul yanlış olduğunda döngü sona erer ve program döngüden sonraki kodla devam eder.

### Basit bir örnek:

```python
x = 1
while x < 100:
   print(x)
   x = x * 2

# Çıktı:
# 1
# 2
# 4
# 8
# 16
# 32
# 64
```

Bu örnekte döngü başladığında `x` değeri 1’dir. `x` 100’den küçük olduğu için program `x`’in değerini yazdırır, ardından `x`’i ikiyle çarpar. Koşul tekrar kontrol edilir, doğruysa döngü devam eder. Bu işlem `x` değeri 128 olana kadar devam eder. Bu noktada koşul yanlış olur ve döngü sona erer.

---

## Sonsuz Döngüler

`while` döngüleri kullanırken dikkatli olmalısınız. Mantık ya da sözdizimi hatası yaparsanız, döngü sonsuz şekilde çalışmaya devam edebilir. Örneğin, yukarıdaki örnekte `x = x * 2` satırı yanlışlıkla girintisiz yazılsaydı, döngü her seferinde `x`’i aynı bırakırdı ve koşul hiçbir zaman yanlış olmayacağı için döngü sonsuza kadar devam ederdi.

### Sonsuz döngüden çıkmak için:

1. **Jupyter Notebook’ta** üst menüdeki **durdur (stop)** butonuna tıklayın.

2. Menüden **Kernel** → **Interrupt** seçeneğini kullanın.

3. Komut modundayken klavyeden `i` tuşuna iki kez basın.

---

## `break` ve `continue`

Koşul hala doğru olsa bile bir döngüyü sonlandırmak mümkündür. Bunun için `break` ifadesi kullanılır.

### Örnek:

```python
x = 1
i = 0
while x < 100:
   if i == 5:
       break
   print(i, x)
   x = x * 2
   i += 1

# Çıktı:
# 0 1
# 1 2
# 2 4
# 3 8
# 4 16
```

Bu örnekte, `i` adlı bir sayaç değişkeni vardır. Her döngüde program:

1. `x < 100` kontrolünü yapar.
2. Ardından `i == 5` olup olmadığını kontrol eder.
3. Eğer `i == 5` ise `break` ifadesiyle döngü sonlandırılır.
4. Aksi halde, `i` ve `x` yazdırılır, `x` ikiyle çarpılır ve `i` bir artırılır.
5. Bu işlem ya `x ≥ 100` ya da `i == 5` olana kadar tekrar eder.

---

Döngünün mevcut yinelemesini atlayıp diğerine geçmek için `continue` ifadesi kullanılır.

### Örnek:

```python
i = 0
while i < 10:
    if i % 3 != 0:
        print(i)
        i += 1
        continue
    i += 1

# Çıktı:
# 1
# 2
# 4
# 5
# 7
# 8
```

Bu örnek, 0–9 aralığındaki ve 3 ile tam bölünemeyen sayıları yazdırır.

Programın yaptığı işlemler:

1. `i < 10` kontrol edilir.
2. `i` değeri 3’e tam bölünemiyorsa (`i % 3 != 0`) ekrana yazdırılır ve `i` bir artırılır.
3. `continue` ifadesi nedeniyle döngü başa döner; böylece kodun geri kalanı çalıştırılmaz (yani çift artış engellenmiş olur).
4. Eğer `i` 3’e tam bölünüyorsa, `if` bloğu atlanır ve doğrudan `i += 1` çalışır.
5. Bu işlem `i` 10 olana kadar devam eder.

---

## Özet – Önemli Noktalar

* `while` döngüsü, belirli bir koşul doğru olduğu sürece kod bloğunu tekrar tekrar çalıştırır.
* `break` ifadesi, koşul hâlâ doğru olsa bile döngüyü sonlandırmak için kullanılır.
* `continue` ifadesi, o anki yinelemeyi atlayıp döngünün sonraki yinelemesine geçmek için kullanılır.

# For Döngüleri

Python’da `for` döngülerini öğrendiniz ve bazı örnekler incelediniz. `For` döngüleri, `while` döngülerine benzer; ancak bir koşul sağlanana kadar sürekli döngü oluşturmak yerine, `for` döngüleri yinelemeli bir dizideki (iterable) her bir öğe üzerinde tek tek döner. Her yinelemede belirli bir işlem veya değerlendirme yapılabilir. Bu işlem yalnızca Python’da değil, çoğu programlama dilinde de oldukça önemlidir. Veri profesyonelleri verileri işlerken `for` döngülerini sıklıkla kullanır. Bu nedenle, becerilerinizi geliştirirken bu yapıya alışmanız çok önemlidir. Bu okuma, `for` döngülerinin temel kavramlarının bir incelemesidir.

---

## For Döngüsü Sözdizimi

`For` döngüsü, yinelemeli (iterable) bir dizideki öğe sayısı kadar bir kod bloğunu çalıştırmanıza izin veren bir kontrol yapısıdır. Bu kursta ilerledikçe yinelemeli diziler hakkında daha fazla şey öğreneceksiniz, ancak bazı örnek veri türleri şunlardır:

* **Stringler**: `'chimichurri'`
* **Listeler**: `[1, 2, 3, 4, 5, 6]`
* **Tuple'lar**: `(1, 2, 3, 4, 5)`
* **Sözlükler**: `{'Ad': 'Anita', 'Yaş': 77}`
* **Kümeler**: `{1, 4, 14, 33}`

> **Not:** Aşağıdaki kod bloğu etkileşimli değildir.

Temel `for` döngüsü sözdizimi:

```python
for item in iterable_sequence:
    # iterable_sequence içindeki her değer için çalışacak kod bloğu
```

`iterable_sequence` herhangi bir yinelemeli veri türü olabilir ve `item` değişkeninin adı size bağlıdır. Ancak, bu değişkene isim verirken bazı yaygın konvansiyonlar vardır:

* Bir string içindeki karakterlerde `char`
* Sayı listelerinde `n` veya `num`

Kodunuzu okuyanların daha kolay anlaması için açıklayıcı isimler tercih etmek faydalıdır. Örneğin, kişilerden oluşan bir liste `names` ise şu şekilde yazılabilir: `for name in names:`.

### Bu değişkenin davranışı hakkında bir not:

Değişkenin değeri her yinelemede güncellenir ve döngü bittikten sonra da bellekte kalmaya devam eder.

### Örnek:

```python
num = 5
y = [1, 2, 3]
for num in y:
    print(num)

print(num)

# 1
# 2
# 3
# 3
```

Görüldüğü gibi, `num` döngü başlamadan önce tanımlıydı. Ancak döngü çalışmaya başladığında `num`’un değeri sırasıyla `y` listesindeki elemanlarla yeniden atanır. Döngü bittiğinde, `num` hâlâ son değerini (3) taşır.

---

## `range()` Fonksiyonu

`For` döngüsü, yinelemeli bir yapıdaki eleman sayısı kadar döner. Ancak bazen belirli bir sayıda işlemi yinelemek istersiniz ama doğrudan üzerinde dönebileceğiniz bir veri yapınız yoktur. Veya düzenli bir sayı dizisi oluşturmanız gerekir. İşte bu noktada `range()` fonksiyonu devreye girer.

`range()` fonksiyonu üç argüman alabilir: `başlangıç`, `bitiş`, `adım`.
Fonksiyonun çıktısı `range` sınıfına ait bir nesnedir.

* Eğer yalnızca **bir argüman** verirseniz, bu `stop` (bitiş) değeri olarak kabul edilir (başlangıç 0, adım 1 olur).
* **İki argüman** verirseniz bunlar `start` ve `stop` olarak yorumlanır (adım yine 1 olur).
* **Üç argüman** verirseniz `start`, `stop`, `step` sırasıyla kullanılır.
  **Not:** Bitiş değeri `range`’in çıktısına dahil edilmez.

### Örnekler:

**A.**

```python
for i in range(3):
    print(i)

# 0
# 1
# 2
```

**B.**

```python
for n in range(2, 5):
    print(n)

# 2
# 3
# 4
```

**C.**

```python
for even_num in range(2, 11, 2):
    print(even_num)

# 2
# 4
# 6
# 8
# 10
```

`range()` fonksiyonunu, örneğin numaralandırılmış listeler oluştururken veya belirli indeksler üzerinde işlem yaparken oldukça kullanışlı bulacaksınız.

---

## İç İçe Döngüler (Nested Loops)

Bazen iç içe yapılar (örneğin liste içinde liste) içerisinden veri çekmeniz gerekir. Bunun için iç içe döngüler kullanılabilir.
İç içe döngü, bir döngünün içinde başka bir döngüdür. Teorik olarak sonsuz sayıda iç içe döngü kullanabilirsiniz, ancak bu kodun okunabilirliğini azaltır.

### Örnek:

```python
students = [['Igor', 'Sokolov'], ['Riko', 'Miyazaki'], ['Tuva', 'Johansen']]
for student in students:
    for name in student:
        print(name)
    print()

# Igor
# Sokolov

# Riko
# Miyazaki

# Tuva
# Johansen
```

Bu örnekte `students` adlı değişken, üç liste içeren bir liste. Her iç liste bir ad ve soyadı içeriyor.

* Dış döngü, her iç listedeki öğrenciyi döner.
* İç döngü ise, her öğrencinin ad ve soyadını yazdırır.
* Her öğrenci sonrası bir boş satır yazdırılır.

---

## Özet – Önemli Noktalar

* `For` döngüsü, bir iterable dizideki öğe sayısı kadar kod bloğunu çalıştırır.
* `range()` fonksiyonu, belirli bir sayı aralığını iterable hale getirerek döngülerde kullanmanızı sağlar.
* İç içe döngüler, daha karmaşık veri yapıları üzerinde işlem yapmanızı sağlar.

Bu güçlü araçlar, bir veri profesyoneli olarak karşılaşacağınız pek çok problemi çözmek için kullanılabilir.

# String (Karakter Dizisi) Indexleme ve Dilimleme

Bildiğiniz gibi, string’ler (karakter dizileri) metni temsil ettikleri için önemli bir veri türüdür. Veri alanında çalışanlar string’lerle sürekli karşılaşır, bu yüzden string’leri farklı şekillerde işleyip yönetebilmeye alışmak önemlidir. Bu okuma, string’lerle çalışırken kullanabileceğiniz iki temel ama güçlü yöntemi gözden geçirir: **indexleme** ve **dilimleme (slicing).**

---

## String Indexleme

**Indexleme**, bir dizideki tek bir öğeye konumu aracılığıyla erişmek anlamına gelir.
**Python’da tüm dizilerde ilk öğe sıfırıncı (0) indekstedir.** Bu, Python’un **sıfır tabanlı indexleme** kullandığı anlamına gelir.
Python dışında birçok dil de sıfır tabanlı indexleme kullanır; ancak bazı diller, örneğin R, Julia ve SAS **bir tabanlı indexleme** kullanır.

Indexleme yapmak için **köşeli parantezler** kullanılır. İşte bazı örnekler:

```python
my_string = 'Mississippi half-step'
print(my_string[0])

my_list = [1, 'unladen', 'swallow']
print(my_list[1])

print(my_list[-1])

# Çıktı:
# M
# unladen
# swallow
```

Bu örneklerde bir string ve bir liste kullanılmıştır.

* `my_string[0]` ile string’in ilk karakteri olan **"M"** seçilir.
* `my_list[1]` ile listedeki ikinci öğe olan **"unladen"** seçilir.
* `my_list[-1]` ile listenin **son öğesi**, yani **"swallow"** negatif indeksleme kullanılarak seçilir.

> **Not:** Eğer nesnede olmayan bir index numarasına erişmeye çalışırsanız **IndexError** hatası alırsınız.

```python
my_list = [1, 'unladen', 'swallow']
my_list[3]

# Hata:
# IndexError: list index out of range
```

---

## Dilimleme (Slicing)

**Dilimleme**, bir diziden belirli bir **aralık** içindeki öğelere erişmektir.
Bunun için köşeli parantez içinde iki indeks arasına `:` (iki nokta) konulur.

Örnekler:

```python
new_string = 'pining for the fjords'
print(new_string[0:3])
print(new_string[:3])

# Çıktı:
# pin
# pin
```

Bu iki örnekte yazım biçimi farklı olsa da aynı sonucu üretir.
Dikkat edilmesi gereken iki nokta:

1. Başlangıç indeksi **dahil**, bitiş indeksi **hariçtir**.
2. Başlangıç indeksi yazılmazsa **0 kabul edilir**, ikinci satırda olduğu gibi.

Bitiş indeksinin yazılmadığı durumlar da benzer şekilde çalışır:

```python
new_string = 'pining for the fjords'
print(new_string[6:21])
print(new_string[6:])
print(len(new_string))

# Çıktı:
#  for the fjords
#  for the fjords
# 21
```

Yukarıda iki farklı yazımla aynı alt string elde edilir.
Bitiş indeksi yazılmazsa, Python bunu dizinin uzunluğu olarak kabul eder.

> **Not:** Slicing (dilimleme) ile, aralık dizi sınırlarını aşsa bile **IndexError oluşmaz**.

```python
new_string = 'pining for the fjords'
print(new_string[6:100])

# Çıktı:
#  for the fjords
```

Burada bitiş indeksi 100 verilmiş olsa da Python, string’in sonuna kadar olan kısmı döndürmüştür. Yani hata vermez.

---

## Özet – Önemli Noktalar

* **Indexleme**: Bir dizideki tek bir öğeye erişim sağlar.
* **Dilimleme**: Bir diziden birden fazla öğeye aralıkla erişim sağlar.
* Her ikisi de **köşeli parantezler** kullanılarak yapılır.
* Dilimlemede, **başlangıç indeksi dahil**, **bitiş indeksi hariçtir.**
* **Negatif indeksler**, dizinin sonundan başa doğru sayar.
* Dilimleme işlemi sırasında dizinin sınırları aşılsa bile hata alınmaz.

Bu araçlar sayesinde string'ler ve diğer yinelemeli veri yapıları üzerinde birçok işlemi kolayca gerçekleştirebilirsiniz. Bu da sizi daha yetkin bir veri uzmanı yapar.

# Dize (String) Biçimlendirme ve Düzenli İfadeler

Metni temsil ettikleri için string’ler oldukça önemli bir veri türüdür. Veri profesyonelleri string’lerle her zaman karşılaşır; bu yüzden onlarla çalışmanın ve manipülasyon yapmanın farklı yöntemlerini öğrenmek çok faydalıdır. Bu bölümde, öğrendiğiniz dize biçimlendirme yöntemleri gözden geçirilecek ve düzenli ifadeler (regular expressions) tanıtılacaktır.

---

## Dize Biçimlendirme

Dize biçimlendirme, string sınıfına ait `format()` metodu ile yapılır. Bu araç, belirli alt dizeleri önceden tanımlı yerlerine yerleştirerek daha genel bir metni dinamik hale getirmenizi sağlar. Şablon metinlerinde dinamik değerleri yerleştirme veya grafik etiketlerinde kullanışlıdır.

### Örnek:

```python
x = 'values'
y = 100
print('''String formatting lets you insert {} into strings.

They can even be numbers, like {}.'''.format(x, y))

# Çıktı:
# String formatting lets you insert values into strings.
# They can even be numbers, like 100.
```

* `{}` içindeki yerler, `format()` metoduna geçirilen argümanlarla sırasıyla doldurulur.
* Üç tırnak `'''` kullanımı, uzun metinleri birden fazla satıra bölmenizi sağlar (özellikle geniş monitör kullanmadığınız durumlarda).

### Anahtar kelimelerle biçimlendirme:

```python
var_a = 'A'
var_b = 'B'
print('{a}, {b}'.format(b=var_b, a=var_a))
# Çıktı: A, B
```

Argümanlar isimle tanımlandığı için, sıralar önemli değildir.

### İndeks numarasıyla biçimlendirme:

```python
var_a = 'A'
var_b = 'B'
print('{1}, {0}'.format(var_a, var_b))  # B, A
print('{0}, {1}'.format(var_a, var_b))  # A, B
```

* İstediğiniz kadar argüman kullanabilir ve indeksleri tekrar edebilirsiniz:

  ```python
  print('{}, {}, {}, {}, {}, {} ...'.format(1, 2, 3, 4, 5, 6))
  # Çıktı: 1, 2, 3, 4, 5, 6 ...
  ```

* Örnek:

  ```python
  print('{0}{1}{0}'.format('abra', 'cad'))
  # Çıktı: abracadabra
  ```

---

## Literals String Interpolation (f-strings)

Python 3.6+ sürümlerinde kullanılan `f-strings`, string içine doğrudan ifadeleri gömmeyi sağlar:

```python
var_a = 1
var_b = 2
print(f'{var_a} + {var_b}')      # 1 + 2
print(f'{var_a + var_b}')        # 3
print(f'var_a = {var_a}\nvar_b = {var_b}')
# Çıktı:
# var_a = 1
# var_b = 2
```

`f` başlatıcısı ile, `{}` içindeki ifadeler doğrudan çalıştırılır.

---

## Sayı Biçimlendirme Seçenekleri (Float Formatting)

* Süslü parantez içinde, `:` ile formatı ayırırsınız.
* `.2f` gibi ifade edilen kısmın anlamı:

  1. Biçimlendirilen değişken
  2. `:` ayırıcı
  3. `.2` hassasiyet (ondalık basamak sayısı)
  4. `f` biçim türü

### Örnek:

```python
num = 1000.987123
f'{num:.2f}'  
# Çıktı: 1000.99
```

* Bazı yaygın biçim türleri:

  | Tür | Anlamı                                                 |
  | --- | ------------------------------------------------------ |
  | `e` | Bilimsel gösterim (örneğin `1.23e+03`)                 |
  | `f` | Sabit nokta biçimi (ondalık kısım belirleyebilirsiniz) |
  | `%` | Yüzde biçimi: sayıyı 100 ile çarpar ve `%` ekler       |

### Örnekler:

```python
print(f'{num:.3e}')        # 1.001e+03
decimal = 0.2497856
print(f'{decimal:.4%}')    # 24.9786%
```

---

## String Metodları

Python string sınıfının birçok hazır metodu vardır. İşte en sık kullanılanlardan bazıları:

* `str.count(sub, start, end)`: Belirtilen alt dizinin belirtilen aralıktaki sayısını verir.

  ```python
  'Happy birthday'.count('y')       # 2
  'Happy birthday'.count('y', 2, 7) # 1
  ```

* `str.find(sub)`: Alt dizinin başladığı ilk indeksi döner; bulunamazsa `-1`.

  ```python
  'Happy birthday'.find('birth')  # 6
  ```

* `str.join(iterable)`: Iterable içindeki parçaları, bu string ile birleştirir.

  ```python
  ' '.join(['Happy', 'birthday', 'to', 'you'])
  # 'Happy birthday to you'
  ```

* `str.partition(sep)`: İlk sep görünüme kadar olan kısmı ayırır ve kalanla üçlü bir tuple döner.

  ```python
  'https://www.google.com/'.partition('.')
  # ('https://www', '.', 'google.com/')
  ```

* `str.replace(old, new[, count])`: Belirtilen alt diziyi yenisiyle değiştirir; istenirse belirli sayıdaki ilkini değiştirir.

  ```python
  'https://www.google.com/'.replace('google', 'youtube')
  # 'https://www.youtube.com/'
  ```

* `str.split([sep])`: String’i sep'e göre parçalar; sep belirtilmezse boşluklar kullanılır.

  ```python
  'Do you know the muffin man?'.split()
  # ['Do', 'you', 'know', 'the', 'muffin', 'man?']
  ```

Metotların daha fazlası için Python'un resmi dökümantasyonuna göz atabilirsin.

---

## Düzenli İfadeler (Regular Expressions)

Düzenli ifadeler (regex), verilerde özel desenleri tanımlamak ve işlemek için güçlü araçlardır. Bu içerikte regex zorunlu olmasa da kavramı bilmen yararlı olur.

### Temel kullanım örneği:

```python
import re
pattern = 'regex_pattern'
match = re.search(pattern, string)
```

#### Örnek:

```python
import re
my_string = 'Three sad tigers swallowed wheat in a wheat field'
re.search('wall', my_string)
# <_sre.SRE_Match object; span=(18, 22), match='wall'>
```

Regex, karmaşık desenlerle eşleşmeleri kontrol etmekte ve metin analizinde güçlüdür.

#### Başka bir basit örnek:

```python
re.search('[bms]ad', my_string)
# Eşleşen örnek: 'sad'
```

Regex, özellikle web kazıma, metin temizliği ve analizinde sık kullanılır.

---

## Özet – Önemli Noktalar

* **Dize biçimlendirme**, tipi ve içerdiği yere göre alt dizeleri string’e gömmenizi sağlar.
* `format()`, `f-strings` ve hassasiyet/format seçenekleri gibi teknikler bu amaca hizmet eder.
* **String metodları**, string’leri işlemek, bölmek, değiştirmek için pratik araçlardır.
* **Düzenli ifadeler (regex)**, metin içindeki desenleri tanımak ve işlemeyi sağlar; ileri düzey temizleme ve analizde faydalıdır.

# Başvuru Rehberi: Listeler

Listelerin Python’daki en önemli veri yapılarından biri olduğunu öğrendiniz. Liste, sıralı bir öğe koleksiyonunu saklamak ve üzerinde işlem yapmak için kullanılan bir veri yapısıdır. Bu öğeler; tamsayı, ondalık sayı, string (metin) hatta başka listeler gibi herhangi bir veri türünde olabilir. Çok yönlü yapılar oldukları için, veri profesyonelleri ve tüm Python geliştiricileri listeleri sıkça kullanır. Bu nedenle nasıl çalıştıklarını öğrenmek önemlidir. Bu okuma, Python öğrenme sürecinizde size yardımcı olmak için hazırlanmış bir liste başvuru rehberidir.

---

## Liste Oluşturma

Python’da liste oluşturmanın iki temel yolu vardır:

* Köşeli parantezler: `[]`
* `list()` fonksiyonu

Köşeli parantezle liste oluştururken, her öğeyi virgülle ayırmalısınız.

### Örnekler:

**String listesi:**

```python
list_a = ['zeytin', 'palmiye', 'hindistancevizi']
print(list_a)
# ['zeytin', 'palmiye', 'hindistancevizi']
```

**Tamsayı listesi:**

```python
list_b = [8, 6, 7, 5, 3, 0, 8]
print(list_b)
# [8, 6, 7, 5, 3, 0, 8]
```

**Karışık veri türleri:**

```python
list_c = ['Abidjan', 14.2, [1, 2, None], 'Zagreb']
print(list_c)
# ['Abidjan', 14.2, [1, 2, None], 'Zagreb']
```

**Boş liste oluşturma:**

```python
empty_list_1 = []
empty_list_2 = list()
# []
```

---

## İndeksleme ve Dilimleme (Slicing)

Tıpkı string’lerde olduğu gibi, listelerdeki öğelere de indeksleme ve dilimleme yoluyla erişebilirsiniz. İlk öğenin indeksi 0’dır, ikinci 1’dir vs. Köşeli parantez kullanılır:

```python
phrase = ['Astra', 'inclinant', 'sed', 'non', 'obligant']
print(phrase[1])
# inclinant
```

**Negatif indeksleme** ile sondan erişim yapılabilir:

```python
print(phrase[-1])
# obligant
```

**Dilimleme** ile alt liste oluşturabilirsiniz:

```python
print(phrase[1:4])
# ['inclinant', 'sed', 'non']
```

> Başlangıç indeksi dahil edilir, bitiş indeksi **dahil edilmez**.

**Başlangıç veya bitiş belirtilmezse:**

```python
print(phrase[:3])  # ['Astra', 'inclinant', 'sed']
print(phrase[3:])  # ['non', 'obligant']
```

---

## Listenin Değiştirilebilirliği (Mutability)

Listeler **değiştirilebilir (mutable)** yapılardır. Yani oluşturduktan sonra içerikleri değiştirilebilir.

**Bireysel bir öğeyi değiştirme:**

```python
my_list = ['Macduff', 'Malcolm', 'Duncan', 'Banquo']
my_list[2] = 'Macbeth'
print(my_list)
# ['Macduff', 'Malcolm', 'Macbeth', 'Banquo']
```

**Bir dilimi değiştirme:**

```python
my_list[1:3] = [1, 2, 3, 4]
print(my_list)
# ['Macduff', 1, 2, 3, 4, 'Banquo']
```

---

## Liste İşlemleri

**Toplama işlemi (`+`) ile birleştirme:**

```python
num_list = [1, 2, 3]
char_list = ['a', 'b', 'c']
num_list + char_list
# [1, 2, 3, 'a', 'b', 'c']
```

**Çarpma işlemi (`*`) ile tekrar:**

```python
list_a = ['a', 'b', 'c']
list_a * 2
# ['a', 'b', 'c', 'a', 'b', 'c']
```

> Listeler **çıkarılamaz veya bölünemez**.

**Bir öğe listede var mı kontrolü:**

```python
num_list = [2, 4, 6]
print(5 in num_list)      # False
print(5 not in num_list)  # True
```

---

## Liste Metotları

Python’daki listeler bir sınıftır ve birçok yerleşik (built-in) metoda sahiptir.

### `append()`

Liste sonuna eleman ekler:

```python
my_list = [0, 1, 1, 2, 3]
my_list.append(5)
print(my_list)
# [0, 1, 1, 2, 3, 5]
```

### `insert()`

Belirli bir konuma eleman ekler:

```python
my_list = ['a', 'b', 'd']
my_list.insert(2, 'c')
print(my_list)
# ['a', 'b', 'c', 'd']
```

### `remove()`

Belirtilen ilk öğeyi siler:

```python
my_list = ['a', 'b', 'd', 'a']
my_list.remove('a')
print(my_list)
# ['b', 'd', 'a']
```

### `pop()`

Verilen konumdaki öğeyi siler ve döner. İndeks verilmezse son öğeyi siler:

```python
my_list = ['a', 'b', 'c']
print(my_list.pop())  # c
print(my_list)        # ['a', 'b']
```

### `clear()`

Tüm öğeleri siler:

```python
my_list = ['a', 'b', 'c']
my_list.clear()
print(my_list)
# []
```

### `index()`

İlk eşleşen öğenin indeksini döner:

```python
my_list = ['a', 'b', 'c', 'a']
my_list.index('a')
# 0
```

### `count()`

Belirli bir öğenin kaç kez geçtiğini döner:

```python
my_list = ['a', 'b', 'c', 'a']
my_list.count('a')
# 2
```

### `sort()`

Listeyi varsayılan olarak artan sıraya göre sıralar. İsteğe bağlı olarak sıralama kriteri verilebilir:

```python
char_list = ['b', 'c', 'a']
num_list = [2, 3, 1]

char_list.sort()
num_list.sort(reverse=True)

print(char_list)  # ['a', 'b', 'c']
print(num_list)   # [3, 2, 1]
```

---

## Ek Kaynaklar

* Daha fazla bilgi için:
  [Python’a Resmi Giriş: Listeler](https://docs.python.org/3/tutorial/introduction.html#lists)
* Daha fazla liste metodu için:
  [Python Veri Yapıları: Listeler](https://docs.python.org/3/tutorial/datastructures.html)

# Listeleri, stringleri (metinleri) ve tuple'ları karşılaştırma

Artık Python’un temel yinelenebilir (iterable) sıralı veri yapılarından bazılarını öğrendiniz; bunlar arasında stringler (metinler), listeler ve tuple’lar yer alır. Bu yapılar birçok benzerliği paylaşsa da, aralarında bazı önemli farklar da vardır. Veri uzmanları, belirli bir problemi çözmek için hangi veri yapısının en uygun olduğunu sık sık belirlemek zorundadır. Bu sınıflar arasındaki ilişkiyi anlamak, işinizde bilinçli kararlar almanıza yardımcı olabilir. Bu metin, string, liste ve tuple’ların benzerliklerini ve farklarını anlamanıza yönelik bir rehberdir.

---

## String'ler (Metinler)

### **Sözdizimi / Oluşturma (Instantiation)**

**Not**: Aşağıdaki kod bloğu etkileşimli değildir.

* Tek tırnak, çift tırnak veya üçlü tırnak kullanılarak oluşturulabilir:

```python
empty_str = ''
my_string1 = 'minerals'
my_string2 = "martin"
my_string3 = """
marathon
golfcart
"""
```

**Not**: Bir stringi birden fazla satıra yaymak için üçlü tırnak kullanmak, satır sonlarını (`\n`) ekler.

```python
my_string3 = """
marathon
golfcart
"""

my_string3

# marathon
# golfcart
```

* `str()` fonksiyonu, string oluşturmak ve diğer veri türlerini string'e dönüştürmek için kullanılabilir.

```python
my_string = str(125)
empty_str = str()
```

### **İçerik**

* String’ler harfler, sayılar, noktalama işaretleri ve boşluklar gibi herhangi bir karakteri içerebilir — açılış ve kapanış tırnak işaretleri arasındaki her şey aynı string'in bir parçasıdır.

### **Değiştirilebilirlik (Mutability)**

* String’ler **değiştirilemezdir (immutable)**. Bu, bir string oluşturulduktan sonra değiştirilemeyeceği anlamına gelir. Bir string'i değiştirdiği gibi görünen her işlem aslında yeni bir string nesnesi oluşturur.

### **Kullanım Alanları**

* String’ler çoğunlukla metin verilerini temsil etmek için kullanılır.

### **Metotlar**

Python string sınıfı, string içeriğini işlemek için birçok yararlı metot içerir. Daha fazla bilgi için [Ortak String İşlemleri](https://docs.python.org/3/library/string.html) bağlantısına bakabilirsiniz.

---

## Listeler

### **Sözdizimi / Oluşturma**

* Köşeli parantezler kullanılır, her eleman virgülle ayrılır:

```python
empty_list = []
my_list = [1, 2, 3, 4, 5]
```

* `list()` fonksiyonu, liste oluşturmak ve iterable (yinelenebilir) veri türlerini listeye dönüştürmek için kullanılabilir.

```python
print(list('rocks'))
print(list(('stones', 'water', 'underground')))
# ['r', 'o', 'c', 'k', 's']
# ['stones', 'water', 'underground']
```

### **İçerik**

* Listeler her veri türünü içerebilir ve farklı türleri bir arada barındırabilir. Örneğin, bir liste string, tamsayı, float, tuple, sözlük ve başka listeler içerebilir.

```python
my_list = [1, 2, 1, 2, 'And through', ['and', 'through']]
```

### **Değiştirilebilirlik**

* Listeler **değiştirilebilirdir (mutable)**. Yani oluşturulduktan sonra içerikleri değiştirilebilir.

```python
num_list = [1, 2, 3]
num_list[0] = 5446
print(num_list)
# [5446, 2, 3]
```

### **Kullanım Alanları**

Listeler çok yönlüdür ve birçok farklı durumda kullanılır. Örnek kullanım alanları:

* İlişkili öğe koleksiyonlarını depolamak
* Üzerinde yineleme (döngü) yapılacak öğeleri depolamak
* Sıralama ve arama işlemleri
* Mevcut verileri değiştirmek
* Hesaplama veya işlemlerin sonuçlarını depolamak

### **Metotlar**

Listelerle ilgili metotlara [Listeler Hakkında Daha Fazla Bilgi](https://docs.python.org/3/tutorial/datastructures.html#more-on-lists) bağlantısından ulaşabilirsiniz.

---

## Tuple'lar

### **Sözdizimi / Oluşturma**

* Normalde parantez içinde, elemanlar virgülle ayrılır:

```python
empty_tuple = ()
my_tuple = (1, 'z')
```

**Not**: Tek öğeli bir tuple oluştururken, sonunda mutlaka bir virgül kullanılmalıdır.

```python
test1 = (1)
test2 = (2,)
print(type(test1))  # <class 'int'>
print(type(test2))  # <class 'tuple'>
```

* Parantezsiz ama virgülle ayrılmış ifadelerle de oluşturulabilir:

```python
tuple1 = 1,
tuple2 = 2, 3
print(type(tuple1))  # <class 'tuple'>
print(type(tuple2))  # <class 'tuple'>
```

* `tuple()` fonksiyonu da tuple oluşturmak için kullanılabilir:

```python
empty_tuple = tuple()
my_tuple = tuple([1, 'z'])
```

### **İçerik**

* Tuple’lar her veri türünden öğe içerebilir ve karışık türler barındırabilir:

```python
my_tuple = (1871, 'all', 'mimsy', ('were', 'the'), ['borogroves'])
```

### **Değiştirilebilirlik**

* Tuple’lar **değiştirilemezdir (immutable)**. Yani oluşturulduktan sonra değiştirilemezler.

### **Kullanım Alanları**

Tuple’lar şu durumlarda sıkça kullanılır:

* Fonksiyonlardan birden fazla değer döndürmek
* Değişkenleri tek satırda atamak (packing/unpacking)
* Sözlüklerde anahtar olarak kullanmak (çünkü tuple’lar değiştirilemez, bu yüzden güvenlidir)
* Verinin yanlışlıkla değiştirilmesini önlemek için veri bütünlüğü sağlamak

### **Metotlar**

Tuple’lar veri güvenliği için tasarlandığından sadece iki metodu vardır:

* `count()` — Belirli bir değerin tuple içinde kaç kez geçtiğini döndürür
* `index()` — Belirli bir değerin ilk geçtiği konumun indeksini döndürür

---

## Önemli Notlar

String, liste ve tuple veri yapıları sıralı ve yinelenebilir (iterable) yapılardır ve birçok benzerlik taşırlar. Ancak, işinizde verimli ve doğru yapıları seçebilmeniz için aralarındaki temel farkları bilmek önemlidir. Bir veri yapısı seçerken, onun nasıl oluşturulduğunu (instantiation), hangi türde veriler içerebileceğini, değiştirilebilirliğini ve kullanım amacını göz önünde bulundurun.

---

## Kaynaklar

* String’ler hakkında daha fazla bilgi için: [Python string dökümantasyonu](https://docs.python.org/3/tutorial/introduction.html#strings)
* Listeler hakkında daha fazla bilgi için: [Python list dökümantasyonu](https://docs.python.org/3/tutorial/introduction.html#lists)
* Tuple’lar hakkında daha fazla bilgi için: [Python standard tuple dökümantasyonu](https://docs.python.org/3/library/stdtypes.html#tuples)

# zip(), enumerate() ve liste kavramsallaştırması (list comprehension)

Artık stringler, listeler ve tuple'lar gibi yinelenebilir (iterable) nesneler hakkında çok şey öğrendiniz ve yakında daha fazlasını da öğreneceksiniz. Bu nesneler Python’un temel veri yapılarının çoğunu oluşturur ve bir veri uzmanı olarak bunlarla sürekli çalışacaksınız. Python’da çalışırken, çoğu zaman aynı işlemleri defalarca yapmanız gerekebilir. Bu yazıda size **zaman kazandıran üç araç** tanıtılacak: `zip()`, `enumerate()` ve **liste kavramsallaştırması (list comprehension)**.

---

## **zip()**

[zip() fonksiyonu](https://docs.python.org/3/library/functions.html#zip), adının da ima ettiği gibi, sıralı veri yapılarını öğe bazında birleştiren yerleşik (built-in) bir Python fonksiyonudur.

Fonksiyon, her bir giriş dizisinden öğeler içeren **tuple'lar üreten bir iterator (yineleyici)** döndürür. *Iterator*, bir koleksiyondaki öğeleri tek tek işlemek için kullanılır ve tüm koleksiyonun aynı anda belleğe yüklenmesini gerektirmez. Iterator’ları döngülerde veya `list()` ve `tuple()` gibi iterable fonksiyonlarla birlikte kullanabilirsiniz.

**Örnek:**

```python
cities = ['Paris', 'Lagos', 'Mumbai']
countries = ['France', 'Nigeria', 'India']
places = zip(cities, countries)

print(places)
print(list(places))

# <zip object at 0x7fb7a6995908>
# [('Paris', 'France'), ('Lagos', 'Nigeria'), ('Mumbai', 'India')]
```

Burada `list()` fonksiyonu, iterator'den oluşan tuple'ları listeye dönüştürmek için kullanılmıştır.

### **zip() kullanırken dikkat edilmesi gerekenler:**

* İki veya daha fazla iterable (yinelenebilir) nesne ile çalışır. Yukarıdaki örnek iki diziyi eşleştiriyor, ama `zip()` daha fazla sayıda diziyle de çalışabilir.
* Giriş nesneleri farklı uzunluklardaysa, oluşan iterator en kısa girişin uzunluğunda olur.
* Sadece tek bir iterable nesne verilirse, her öğeyi tek öğeli tuple olarak döndüren bir iterator üretir.

---

### **Unzip işlemi (çözme)**

`*` (yıldız) operatörü ile ziplenmiş bir nesne tekrar ayrıştırılabilir:

```python
scientists = [('Nikola', 'Tesla'), ('Charles', 'Darwin'), ('Marie', 'Curie')]
given_names, surnames = zip(*scientists)
print(given_names)
print(surnames)

# ('Nikola', 'Charles', 'Marie')
# ('Tesla', 'Darwin', 'Curie')
```

Bu işlem, orijinal listedeki tuple'ları öğe bazında çözüp ayrı değişkenlere ayırır.

---

## **enumerate()**

[enumerate() fonksiyonu](https://docs.python.org/3/library/functions.html#enumerate), bir dizide gezinirken her öğenin indeksini de takip etmenizi sağlayan yerleşik bir Python fonksiyonudur. `zip()` gibi, `enumerate()` de **indeks ve öğe çiftlerini üreten bir iterator** döndürür.

**Örnek:**

```python
letters = ['a', 'b', 'c']
for index, letter in enumerate(letters):
   print(index, letter)

# 0 a
# 1 b
# 2 c
```

**Varsayılan başlangıç indeksi sıfırdır**, ancak bunu değiştirebilirsiniz:

```python
letters = ['a', 'b', 'c']
for index, letter in enumerate(letters, 2):
   print(index, letter)

# 2 a
# 3 b
# 4 c
```

Bu örnekte, `enumerate()` fonksiyonuna 2 değeri verildi ve dönen iterator’un ilk elemanı indeks olarak 2 ile başladı. `enumerate()`, bir öğenin listedeki konumunun işlem üzerinde etkisi olacağı durumlarda kullanışlıdır.

---

## **List comprehension (Liste kavramsallaştırması)**

[List comprehension](https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions), Python’daki en kullanışlı araçlardan biridir. Var olan bir iterable yapıdaki verilere dayalı olarak **yeni bir listeyi kısa ve etkili şekilde oluşturmanın** bir yoludur.

Temel sözdizimi şöyledir:

```python
my_list = [expression for element in iterable if condition]
```

Bu yapının bileşenleri:

* **expression (ifade)**: Her öğe için yapılacak işlem.
* **element (öğe)**: Her öğeyi temsil eden değişken.
* **iterable**: Yinelenebilir veri kaynağı (liste, string, vs.).
* **condition (şart)**: Doğru/yanlış (True/False) olarak değerlendirilen bir ifade. (İsteğe bağlıdır.)

---

### **Örnekler**

**Tüm öğelere 10 ekleyen list comprehension:**

```python
numbers = [1, 2, 3, 4, 5]
new_list = [x + 10 for x in numbers]
print(new_list)

# [11, 12, 13, 14, 15]
```

Burada:

* `x + 10` ➝ ifade
* `x` ➝ öğe
* `numbers` ➝ iterable
* Şart yok

---

**Sadece 5 harften uzun kelimelerin ilk ve son harfini tuple olarak çıkaran list comprehension:**

```python
words = ['Emotan', 'Amina', 'Ibeno', 'Sankwala']
new_list = [(word[0], word[-1]) for word in words if len(word) > 5]
print(new_list)

# [('E', 'n'), ('S', 'a')]
```

Bu örnekte:

* `word[0], word[-1]` ➝ ifade (tuple üretimi)
* `len(word) > 5` ➝ filtreleme şartı (5’ten kısa kelimeleri dışlar)

---

## **Önemli Noktalar (Key takeaways)**

* `zip()`, `enumerate()` ve **list comprehension**, döngülere olan bağımlılığı azaltarak kodunuzu daha **etkili ve okunabilir** hale getirir.
* Bu araçlar iterable yapılarla çalışırken zaman kazandırır ve veri işlemlerini daha dinamik bir hale getirir.
* Bu temel araçları iyi anlamak, verilerinizi işlerken daha güçlü çözümler üretmenizi sağlar.

# Başvuru Kılavuzu: Sözlükler (Dictionaries)

Artık Python'daki sözlük veri yapısıyla tanıştınız ve onun gücünü ve kullanışlılığını keşfetmeye başladınız. Sözlüklerin, verileri **anahtar-değer (key-value)** çiftleriyle saklama ve geri çağırma imkânı sunduğunu da öğrendiniz. Veri uzmanları sözlükleri pek çok görev için kullanır, bu yüzden onların nasıl çalıştığını iyi bilmek önemlidir. Bu okuma, Python öğrenme yolculuğunuzda size yardımcı olmak üzere hazırlanmış bir **sözlük başvuru kılavuzudur.**

---

## **Sözlük Oluşturmak**

Python’da sözlük oluşturmanın iki temel yolu vardır:

* Süslü parantezler: `{}`
* `dict()` fonksiyonu

Süslü parantezlerle bir sözlük oluştururken, her öğeyi **iki nokta üst üste** (`:`) ile ayırın. Örneğin, aşağıdaki kod kıtaları anahtar (key) ve en küçük ülkeleri değer (value) olarak içeren bir sözlük oluşturur:

```python
smallest_countries = {'Africa': 'Seychelles',
                     'Asia': 'Maldives',
                     'Europe': 'Vatican City',
                     'Oceania': 'Nauru',
                     'North America': 'St. Kitts and Nevis',
                     'South America': 'Suriname'
                     }
```

Boş bir sözlük oluşturmak için ise boş süslü parantezler ya da `dict()` fonksiyonunu kullanabilirsiniz:

```python
empty_dict_1 = {}
empty_dict_2 = dict()
```

`dict()` fonksiyonu farklı bir sözdizimi kullanır: Anahtarlar fonksiyonun **anahtar kelime argümanları** olarak girilir ve `=` ile değer atanır:

```python
smallest_countries = dict(africa='Seychelles',
                         asia='Maldives',
                         europe='Vatican City',
                         oceania='Nauru',
                         north_america='St. Kitts and Nevis',
                         south_america ='Suriname'
)
```

**Not:** Bu yöntemde anahtarlar string (tırnak içinde) girilmediği için, boşluk içeremezler.

**Anahtarlar ve değerlerle ilgili bazı önemli notlar:**

* **Sözlük Anahtarları (Keys):** String, sayı veya tuple gibi **değiştirilemez (immutable)** veri türlerinden olabilir.
* **Sözlük Değerleri (Values):** Herhangi bir veri türünden olabilir—değiştirilebilir (mutable) veya değiştirilemez—hatta başka sözlükler ya da nesneler bile olabilir.
* Her anahtar yalnızca bir değere karşılık gelir. Örneğin şu kod hata verir:

```python
invalid_dict = {'numbers': 1, 2, 3}  # Geçersiz sözlük

# SyntaxError: invalid syntax
```

Ama birden fazla değeri başka bir veri yapısı (örneğin liste) içinde verirseniz geçerli olur:

```python
valid_dict = {'numbers': [1, 2, 3]}
print(valid_dict)

# {'numbers': [1, 2, 3]}
```

---

## **Sözlüklerle Çalışmak**

### **Değer Erişimi (Access values)**

Belirli bir değere ulaşmak için, anahtarı köşeli parantez içinde kullanın:

```python
my_dict = {'nums': [1, 2, 3],
           'abc': ['a', 'b', 'c']
          }

print(my_dict['nums'])

# [1, 2, 3]
```

Tüm değerlere ulaşmak için `values()` metodunu kullanabilirsiniz:

```python
print(my_dict.values())

# dict_values([[1, 2, 3], ['a', 'b', 'c']])
```

---

### **Yeni Anahtar Ekleme (Assign new keys)**

Sözlükler **değiştirilebilir (mutable)** yapılardır. Var olan sözlüklere yeni anahtar-değer çifti ekleyebilir veya mevcut olanları değiştirebilirsiniz:

```python
my_dict = {'nums': [1, 2, 3],
           'abc': ['a', 'b', 'c']
          }

# Yeni bir 'floats' anahtarı ekle
my_dict['floats'] = [1.0, 2.0, 3.0]

print(my_dict)

# {'nums': [1, 2, 3], 'abc': ['a', 'b', 'c'], 'floats': [1.0, 2.0, 3.0]}
```

---

### **Anahtarın Var Olup Olmadığını Kontrol Etmek**

Bir anahtar sözlükte var mı diye kontrol etmek için `in` anahtar kelimesini kullanın:

```python
smallest_countries = {
    'Africa': 'Seychelles',
    'Asia': 'Maldives',
    'Europe': 'Vatican City',
    'Oceania': 'Nauru',
    'North America': 'St. Kitts and Nevis',
    'South America': 'Suriname'
}

print('Africa' in smallest_countries)       # True
print('Asia' not in smallest_countries)     # False
```

---

### **Anahtar-Değer Çiftini Silmek**

Bir anahtar-değer çiftini silmek için `del` anahtar kelimesi kullanılır:

```python
my_dict = {'nums': [1, 2, 3],
           'abc': ['a', 'b', 'c']
          }

del my_dict['abc']
print(my_dict)

# {'nums': [1, 2, 3]}
```

---

## **Sözlük Metotları (Dictionary Methods)**

Sözlükler, Python’un temel sınıflarındandır. Sınıflar, veriyi onunla çalışacak araçlarla birlikte sunar. Bu araçlardan biri de metotlardır (methods). İşte sık kullanılan bazı sözlük metotları:

---

### **items()**

Sözlüğün `(anahtar, değer)` çiftlerinin bir görünümünü döndürür:

```python
print(my_dict.items())

# dict_items([('nums', [1, 2, 3])])
```

---

### **keys()**

Sözlüğün yalnızca **anahtarlarının** bir görünümünü döndürür:

```python
print(my_dict.keys())

# dict_keys(['nums'])
```

---

### **values()**

Sözlüğün yalnızca **değerlerinin** bir görünümünü döndürür:

```python
print(my_dict.values())

# dict_values([[1, 2, 3]])
```

**Not:** Bu metodların döndürdüğü nesneler "view objects" (görünüm nesneleri) olarak adlandırılır. Bu görünüm, sözlükteki değişiklikleri **dinamik** olarak yansıtır. Ayrıca bu görünümler üzerinde dolaşılabilir (iterable) ve eleman üyelik testleri yapılabilir (`in` kullanarak).

---

## **Ek Kaynaklar**

* Daha fazla bilgi için: [Python sözlük dokümantasyonu](https://docs.python.org/3/tutorial/datastructures.html#dictionaries)
* Diğer sözlük metotları için: [Python mapping types](https://docs.python.org/3/library/stdtypes.html#mapping-types-dict)
* View objects hakkında detaylı bilgi için: [Python dictionary view objects](https://docs.python.org/3/library/stdtypes.html#dict-views)
